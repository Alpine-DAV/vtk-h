//-----------------------------------------------------------------------------
///
/// file: t_vtk-h_dataset.cpp
///
//-----------------------------------------------------------------------------

#include "gtest/gtest.h"

#include <vtkh/vtkh.hpp>
#include <vtkh/DataSet.hpp>
#include <vtkh/filters/MarchingCubes.hpp>
#include <vtkh/rendering/RayTracer.hpp>
#include <vtkh/rendering/Scene.hpp>
#include "t_test_utils.hpp"

#include <vtkm/cont/DataSetBuilderUniform.h>
#include <vtkm/cont/DataSetFieldAdd.h>
#include <vtkm/cont/PartitionedDataSet.h>
#include <vtkm/cont/EnvironmentTracker.h>

#include <iostream>
#ifdef VTKH_PARALLEL
#include <mpi.h>
#endif


using ValueType = vtkm::Float64;

#ifndef VTKH_PARALLEL
bool ReadTestData(const char* filename, vtkm::cont::DataSet& inDataSet)
{
  const int mpiRank = 0;
#else
bool ReadTestData(const char* filename, vtkm::cont::PartitionedDataSet& inDataSet,
                  int mpiRank, int mpiSize)
{
#endif

  std::ifstream inFile(filename);
  if (inFile.bad())
    return false;

  // Read the dimensions of the mesh, i.e,. number of elementes in x, y, and z
  std::vector<std::size_t> dims;
  std::string line;
  getline(inFile, line);
  std::istringstream linestream(line);
  std::size_t dimVertices;
  while (linestream >> dimVertices)
  {
    dims.push_back(dimVertices);
  }

  // Compute the number of vertices, i.e., xdim * ydim * zdim
  unsigned short nDims = static_cast<unsigned short>(dims.size());
  std::size_t nVertices = static_cast<std::size_t>(
    std::accumulate(dims.begin(), dims.end(), 1, std::multiplies<std::size_t>()));

  // Print the mesh metadata
  if (mpiRank == 0)
  {
    std::cout << "Number of dimensions: " << nDims << std::endl;
    std::cout << "Number of mesh vertices: " << nVertices << std::endl;
  }
  // Check the the number of dimensiosn is either 2D or 3D
  bool invalidNumDimensions = (nDims < 2 || nDims > 3);
  if (mpiRank == 0)
  {
    if (invalidNumDimensions)
    {
      std::cout << "The input mesh is " << nDims << "D. Input data must be either 2D or 3D."
                << std::endl;
    }
  }
  if (invalidNumDimensions)
  {
    return false;
  }

  // Read data
  std::vector<ValueType> values(nVertices);
  for (std::size_t vertex = 0; vertex < nVertices; ++vertex)
  {
    inFile >> values[vertex];
  }

  // finish reading the data
  inFile.close();

  vtkm::cont::DataSetBuilderUniform dsb;
#ifndef VTKH_PARALLEL
  {
    // build the input dataset
    // 2D data
    if (nDims == 2)
    {
      vtkm::Id2 vdims;
      vdims[0] = static_cast<vtkm::Id>(dims[0]);
      vdims[1] = static_cast<vtkm::Id>(dims[1]);
      inDataSet = dsb.Create(vdims);
    }
    // 3D data
    else
    {
      vtkm::Id3 vdims;
      vdims[0] = static_cast<vtkm::Id>(dims[0]);
      vdims[1] = static_cast<vtkm::Id>(dims[1]);
      vdims[2] = static_cast<vtkm::Id>(dims[2]);
      inDataSet = dsb.Create(vdims);
    }
    vtkm::cont::DataSetFieldAdd dsf;
    dsf.AddPointField(inDataSet, "values", values);
  }
#else // VTKH_PARALLEL
  int numBlocks = mpiSize;
  int blocksPerRank = 1;
  vtkm::cont::ArrayHandle<vtkm::Id3> localBlockIndices;
  vtkm::cont::ArrayHandle<vtkm::Id3> localBlockOrigins;
  vtkm::cont::ArrayHandle<vtkm::Id3> localBlockSizes;
  localBlockIndices.Allocate(blocksPerRank);
  localBlockOrigins.Allocate(blocksPerRank);
  localBlockSizes.Allocate(blocksPerRank);
  auto localBlockIndicesPortal = localBlockIndices.GetPortalControl();
  auto localBlockOriginsPortal = localBlockOrigins.GetPortalControl();
  auto localBlockSizesPortal = localBlockSizes.GetPortalControl();
  {
    vtkm::Id lastDimSize =
      (nDims == 2) ? static_cast<vtkm::Id>(dims[1]) : static_cast<vtkm::Id>(dims[2]);
    if (mpiSize > (lastDimSize / 2.))
    {
      if (mpiRank == 0)
      {
        std::cout << "Number of ranks to large for data. Use " << lastDimSize / 2
                  << " or fewer ranks" << std::endl;
      }
      return false;
    }
    vtkm::Id standardBlockSize = (vtkm::Id)(lastDimSize / numBlocks);
    vtkm::Id blockSize = standardBlockSize;
    vtkm::Id blockSliceSize =
      nDims == 2 ? static_cast<vtkm::Id>(dims[0]) : static_cast<vtkm::Id>((dims[0] * dims[1]));
    vtkm::Id blockNumValues = blockSize * blockSliceSize;

    vtkm::Id startBlock = blocksPerRank * mpiRank;
    vtkm::Id endBlock = startBlock + blocksPerRank;
    for (vtkm::Id blockIndex = startBlock; blockIndex < endBlock; ++blockIndex)
    {
      vtkm::Id localBlockIndex = blockIndex - startBlock;
      vtkm::Id blockStart = blockIndex * blockNumValues;
      vtkm::Id blockEnd = blockStart + blockNumValues;
      if (blockIndex < (numBlocks - 1)) // add overlap between regions
      {
        blockEnd += blockSliceSize;
      }
      else
      {
        blockEnd = lastDimSize * blockSliceSize;
      }
      vtkm::Id currBlockSize = (vtkm::Id)((blockEnd - blockStart) / blockSliceSize);

      vtkm::cont::DataSet ds;

      // 2D data
      if (nDims == 2)
      {
        vtkm::Id2 vdims;
        vdims[0] = static_cast<vtkm::Id>(currBlockSize);
        vdims[1] = static_cast<vtkm::Id>(dims[0]);
        vtkm::Vec<ValueType, 2> origin(0, blockIndex * blockSize);
        vtkm::Vec<ValueType, 2> spacing(1, 1);
        ds = dsb.Create(vdims, origin, spacing);

        localBlockIndicesPortal.Set(localBlockIndex, vtkm::Id3(blockIndex, 0, 0));
        localBlockOriginsPortal.Set(localBlockIndex,
                                    vtkm::Id3((blockStart / blockSliceSize), 0, 0));
        localBlockSizesPortal.Set(localBlockIndex,
                                  vtkm::Id3(currBlockSize, static_cast<vtkm::Id>(dims[0]), 0));
      }
      // 3D data
      else
      {
        vtkm::Id3 vdims;
        vdims[0] = static_cast<vtkm::Id>(dims[0]);
        vdims[1] = static_cast<vtkm::Id>(dims[1]);
        vdims[2] = static_cast<vtkm::Id>(currBlockSize);
        vtkm::Vec<ValueType, 3> origin(0, 0, (blockIndex * blockSize));
        vtkm::Vec<ValueType, 3> spacing(1, 1, 1);
        ds = dsb.Create(vdims, origin, spacing);

        localBlockIndicesPortal.Set(localBlockIndex, vtkm::Id3(0, 0, blockIndex));
        localBlockOriginsPortal.Set(localBlockIndex,
                                    vtkm::Id3(0, 0, (blockStart / blockSliceSize)));
        localBlockSizesPortal.Set(
          localBlockIndex,
          vtkm::Id3(static_cast<vtkm::Id>(dims[0]), static_cast<vtkm::Id>(dims[1]), currBlockSize));
      }

      std::vector<ValueType> subValues((values.begin() + blockStart),
                                           (values.begin() + blockEnd));

      vtkm::cont::DataSetFieldAdd dsf;
      dsf.AddPointField(ds, "values", subValues);
      inDataSet.AppendPartition(ds);
    }
  }
#endif // VTKH_PARALLEL
  return true;
}

 using ValueArray = vtkm::cont::ArrayHandle<ValueType>;

#cmakedefine TESTS_SOURCE_DIR "@TESTS_SOURCE_DIR@"
//----------------------------------------------------------------------------
TEST(vtkh_contour_tree, vtkh_contour_tree)
{
  vtkh::DataSet data_set;
  std::string fileName = std::string(TESTS_SOURCE_DIR) + "/fuel.txt";

#ifndef VTKH_PARALLEL
  vtkm::cont::DataSet vtkmData;
  ReadTestData(fileName.c_str(), vtkmData);
  data_set.AddDomain(vtkmData, 0);
#else
  MPI_Init(NULL, NULL);
  int mpiSize, mpiRank;
  MPI_Comm_size(MPI_COMM_WORLD, &mpiSize);
  MPI_Comm_rank(MPI_COMM_WORLD, &mpiRank);
  vtkh::SetMPICommHandle(MPI_Comm_c2f(MPI_COMM_WORLD));

  // Setup vtk-m GlobalCommuncator. This is need because the GlobalCommuncator does not setup it self up right.
  diy::mpi::communicator tempComm(MPI_COMM_WORLD);
  GlobalCommuncator = tempComm;

  vtkm::cont::PartitionedDataSet mb;
  ReadTestData(fileName.c_str(), mb, mpiRank, mpiSize);
  for (vtkm::Id id = 0; id < mb.GetNumberOfPartitions(); ++id)
  {
    vtkm::cont::DataSet dom = mb.GetPartition(id);
    ValueArray dataField;
    dom.GetField("values").GetData().CopyTo(dataField);
    data_set.AddDomain(dom, id);
  }
#endif
  vtkh::MarchingCubes marcher;
  marcher.SetInput(&data_set);
  marcher.SetField("values");

  int num_levels = 5;
  marcher.SetLevels(num_levels);
  marcher.SetUseContourTree(true);
  marcher.AddMapField("values");
  marcher.Update();
  std::vector<double> isoValues = marcher.GetIsoValues();
  std::sort(isoValues.begin(), isoValues.end());

  EXPECT_FLOAT_EQ(isoValues[0], 0);

  // TODO temp change to reduce the input data size.
  //EXPECT_FLOAT_EQ(isoValues[0], 1e-05);
  //EXPECT_FLOAT_EQ(isoValues[1], 82);
  //EXPECT_FLOAT_EQ(isoValues[2], 133);
  //EXPECT_FLOAT_EQ(isoValues[3], 168);
  //EXPECT_FLOAT_EQ(isoValues[4], 177);

#ifdef VTKH_PARALLEL
  MPI_Finalize();
#endif
}
